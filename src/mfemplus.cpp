
#include <iomanip>
#include <iostream>

#include "mfemplus.h"

using namespace std;

Meshplus::Meshplus() : Mesh() {}
Meshplus::Meshplus(ParMesh *pmesh_) : Mesh(*pmesh_) {}
Meshplus::Meshplus(Mesh *mesh_) : Mesh(*mesh_) {}

void Meshplus::PrintVTK_eta(std::ostream &out, Vector &other_attri) {
  out << "# vtk DataFile Version 3.0\n"
         "Generated by MFEM\n"
         "ASCII\n"
         "DATASET UNSTRUCTURED_GRID\n";

  if (Nodes == NULL) {
    out << "POINTS " << NumOfVertices << " double\n";
    for (int i = 0; i < NumOfVertices; i++) {
      out << vertices[i](0);
      int j;
      for (j = 1; j < spaceDim; j++) {
        out << ' ' << vertices[i](j);
      }
      for (; j < 3; j++) {
        out << ' ' << 0.0;
      }
      out << '\n';
    }
  } else {
    Array<int> vdofs(3);
    out << "POINTS " << Nodes->FESpace()->GetNDofs() << " double\n";
    for (int i = 0; i < Nodes->FESpace()->GetNDofs(); i++) {
      vdofs.SetSize(1);
      vdofs[0] = i;
      Nodes->FESpace()->DofsToVDofs(vdofs);
      out << (*Nodes)(vdofs[0]);
      int j;
      for (j = 1; j < spaceDim; j++) {
        out << ' ' << (*Nodes)(vdofs[j]);
      }
      for (; j < 3; j++) {
        out << ' ' << 0.0;
      }
      out << '\n';
    }
  }

  int order = -1;
  if (Nodes == NULL) {
    int size = 0;
    for (int i = 0; i < NumOfElements; i++) {
      size += elements[i]->GetNVertices() + 1;
    }
    out << "CELLS " << NumOfElements << ' ' << size << '\n';
    for (int i = 0; i < NumOfElements; i++) {
      const int *v = elements[i]->GetVertices();
      const int nv = elements[i]->GetNVertices();
      out << nv;
      for (int j = 0; j < nv; j++) {
        out << ' ' << v[j];
      }
      out << '\n';
    }
    order = 1;
  } else {
    Array<int> dofs;
    int size = 0;
    for (int i = 0; i < NumOfElements; i++) {
      Nodes->FESpace()->GetElementDofs(i, dofs);
      MFEM_ASSERT(Dim != 0 || dofs.Size() == 1,
                  "Point meshes should have a single dof per element");
      size += dofs.Size() + 1;
    }
    out << "CELLS " << NumOfElements << ' ' << size << '\n';
    const char *fec_name = Nodes->FESpace()->FEColl()->Name();

    if (!strcmp(fec_name, "Linear") || !strcmp(fec_name, "H1_0D_P1") ||
        !strcmp(fec_name, "H1_1D_P1") || !strcmp(fec_name, "H1_2D_P1") ||
        !strcmp(fec_name, "H1_3D_P1")) {
      order = 1;
    } else if (!strcmp(fec_name, "Quadratic") ||
               !strcmp(fec_name, "H1_1D_P2") || !strcmp(fec_name, "H1_2D_P2") ||
               !strcmp(fec_name, "H1_3D_P2")) {
      order = 2;
    }
    if (order == -1) {
      mfem::err << "Mesh::PrintVTK : can not save '" << fec_name
                << "' elements!" << std::endl;
      mfem_error();
    }
    for (int i = 0; i < NumOfElements; i++) {
      Nodes->FESpace()->GetElementDofs(i, dofs);
      out << dofs.Size();
      if (order == 1) {
        for (int j = 0; j < dofs.Size(); j++) {
          out << ' ' << dofs[j];
        }
      } else if (order == 2) {
        const int *vtk_mfem;
        switch (elements[i]->GetGeometryType()) {
        case Geometry::SEGMENT:
        case Geometry::TRIANGLE:
        case Geometry::SQUARE:
          vtk_mfem = vtk_quadratic_hex;
          break; // identity map
        case Geometry::TETRAHEDRON:
          vtk_mfem = vtk_quadratic_tet;
          break;
        case Geometry::PRISM:
          vtk_mfem = vtk_quadratic_wedge;
          break;
        case Geometry::CUBE:
        default:
          vtk_mfem = vtk_quadratic_hex;
          break;
        }
        for (int j = 0; j < dofs.Size(); j++) {
          out << ' ' << dofs[vtk_mfem[j]];
        }
      }
      out << '\n';
    }
  }

  out << "CELL_TYPES " << NumOfElements << '\n';
  for (int i = 0; i < NumOfElements; i++) {
    int vtk_cell_type = 5;
    Geometry::Type geom_type = GetElement(i)->GetGeometryType();
    if (order == 1) {
      switch (geom_type) {
      case Geometry::POINT:
        vtk_cell_type = 1;
        break;
      case Geometry::SEGMENT:
        vtk_cell_type = 3;
        break;
      case Geometry::TRIANGLE:
        vtk_cell_type = 5;
        break;
      case Geometry::SQUARE:
        vtk_cell_type = 9;
        break;
      case Geometry::TETRAHEDRON:
        vtk_cell_type = 10;
        break;
      case Geometry::CUBE:
        vtk_cell_type = 12;
        break;
      case Geometry::PRISM:
        vtk_cell_type = 13;
        break;
      default:
        break;
      }
    } else if (order == 2) {
      switch (geom_type) {
      case Geometry::SEGMENT:
        vtk_cell_type = 21;
        break;
      case Geometry::TRIANGLE:
        vtk_cell_type = 22;
        break;
      case Geometry::SQUARE:
        vtk_cell_type = 28;
        break;
      case Geometry::TETRAHEDRON:
        vtk_cell_type = 24;
        break;
      case Geometry::CUBE:
        vtk_cell_type = 29;
        break;
      case Geometry::PRISM:
        vtk_cell_type = 32;
        break;
      default:
        break;
      }
    }

    out << vtk_cell_type << '\n';
  }

  // write attributes
  out << "CELL_DATA " << NumOfElements << '\n'
      << "SCALARS cell_scalars double\n"
      << "LOOKUP_TABLE default\n";
  for (int i = 0; i < NumOfElements; i++) {
    out << other_attri[i] << '\n';
  }
  out.flush();
}

void Meshplus::write_out_node_info_vtk(
    std::ostream &out, Vector &node_data
    // const std::string name, std::vector<double>& node_data
) {
  out << "# vtk DataFile Version 3.0\n"
         "Generated by MFEM\n"
         "ASCII\n"
         "DATASET UNSTRUCTURED_GRID\n";

  if (Nodes == NULL) {
    out << "POINTS " << NumOfVertices << " double\n";
    for (int i = 0; i < NumOfVertices; i++) {
      out << vertices[i](0);
      int j;
      for (j = 1; j < spaceDim; j++) {
        out << ' ' << vertices[i](j);
      }
      for (; j < 3; j++) {
        out << ' ' << 0.0;
      }
      out << '\n';
    }
  } else {
    Array<int> vdofs(3);
    out << "POINTS " << Nodes->FESpace()->GetNDofs() << " double\n";
    for (int i = 0; i < Nodes->FESpace()->GetNDofs(); i++) {
      vdofs.SetSize(1);
      vdofs[0] = i;
      Nodes->FESpace()->DofsToVDofs(vdofs);
      out << (*Nodes)(vdofs[0]);
      int j;
      for (j = 1; j < spaceDim; j++) {
        out << ' ' << (*Nodes)(vdofs[j]);
      }
      for (; j < 3; j++) {
        out << ' ' << 0.0;
      }
      out << '\n';
    }
  }

  int order = -1;
  if (Nodes == NULL) {
    int size = 0;
    for (int i = 0; i < NumOfElements; i++) {
      size += elements[i]->GetNVertices() + 1;
    }
    out << "CELLS " << NumOfElements << ' ' << size << '\n';
    for (int i = 0; i < NumOfElements; i++) {
      const int *v = elements[i]->GetVertices();
      const int nv = elements[i]->GetNVertices();
      out << nv;
      for (int j = 0; j < nv; j++) {
        out << ' ' << v[j];
      }
      out << '\n';
    }
    order = 1;
  } else {
    Array<int> dofs;
    int size = 0;
    for (int i = 0; i < NumOfElements; i++) {
      Nodes->FESpace()->GetElementDofs(i, dofs);
      MFEM_ASSERT(Dim != 0 || dofs.Size() == 1,
                  "Point meshes should have a single dof per element");
      size += dofs.Size() + 1;
    }
    out << "CELLS " << NumOfElements << ' ' << size << '\n';
    const char *fec_name = Nodes->FESpace()->FEColl()->Name();

    if (!strcmp(fec_name, "Linear") || !strcmp(fec_name, "H1_0D_P1") ||
        !strcmp(fec_name, "H1_1D_P1") || !strcmp(fec_name, "H1_2D_P1") ||
        !strcmp(fec_name, "H1_3D_P1")) {
      order = 1;
    } else if (!strcmp(fec_name, "Quadratic") ||
               !strcmp(fec_name, "H1_1D_P2") || !strcmp(fec_name, "H1_2D_P2") ||
               !strcmp(fec_name, "H1_3D_P2")) {
      order = 2;
    }
    if (order == -1) {
      mfem::err << "Mesh::PrintVTK : can not save '" << fec_name
                << "' elements!" << std::endl;
      mfem_error();
    }
    for (int i = 0; i < NumOfElements; i++) {
      Nodes->FESpace()->GetElementDofs(i, dofs);
      out << dofs.Size();
      if (order == 1) {
        for (int j = 0; j < dofs.Size(); j++) {
          out << ' ' << dofs[j];
        }
      } else if (order == 2) {
        const int *vtk_mfem;
        switch (elements[i]->GetGeometryType()) {
        case Geometry::SEGMENT:
        case Geometry::TRIANGLE:
        case Geometry::SQUARE:
          vtk_mfem = vtk_quadratic_hex;
          break; // identity map
        case Geometry::TETRAHEDRON:
          vtk_mfem = vtk_quadratic_tet;
          break;
        case Geometry::PRISM:
          vtk_mfem = vtk_quadratic_wedge;
          break;
        case Geometry::CUBE:
        default:
          vtk_mfem = vtk_quadratic_hex;
          break;
        }
        for (int j = 0; j < dofs.Size(); j++) {
          out << ' ' << dofs[vtk_mfem[j]];
        }
      }
      out << '\n';
    }
  }

  out << "CELL_TYPES " << NumOfElements << '\n';
  for (int i = 0; i < NumOfElements; i++) {
    int vtk_cell_type = 5;
    Geometry::Type geom_type = GetElement(i)->GetGeometryType();
    if (order == 1) {
      switch (geom_type) {
      case Geometry::POINT:
        vtk_cell_type = 1;
        break;
      case Geometry::SEGMENT:
        vtk_cell_type = 3;
        break;
      case Geometry::TRIANGLE:
        vtk_cell_type = 5;
        break;
      case Geometry::SQUARE:
        vtk_cell_type = 9;
        break;
      case Geometry::TETRAHEDRON:
        vtk_cell_type = 10;
        break;
      case Geometry::CUBE:
        vtk_cell_type = 12;
        break;
      case Geometry::PRISM:
        vtk_cell_type = 13;
        break;
      default:
        break;
      }
    } else if (order == 2) {
      switch (geom_type) {
      case Geometry::SEGMENT:
        vtk_cell_type = 21;
        break;
      case Geometry::TRIANGLE:
        vtk_cell_type = 22;
        break;
      case Geometry::SQUARE:
        vtk_cell_type = 28;
        break;
      case Geometry::TETRAHEDRON:
        vtk_cell_type = 24;
        break;
      case Geometry::CUBE:
        vtk_cell_type = 29;
        break;
      case Geometry::PRISM:
        vtk_cell_type = 32;
        break;
      default:
        break;
      }
    }

    out << vtk_cell_type << '\n';
  }

  // std::cout << this->GetNV() << std::endl;
  // std::cout << NumOfVertices << std::endl;

  // write attributes
  out << "\nPOINT_DATA\t " << NumOfVertices << '\n'
      << "SCALARS potential double 1\n"
      << "LOOKUP_TABLE default\n";
  for (int i = 0; i < NumOfVertices; i++) {
    out << node_data(i) << '\n';
  }
  out.flush();
}

void LVCoefficient::Eval(DenseMatrix &M, ElementTransformation &T,
                         const IntegrationPoint &ip) {
  M = mat[T.Attribute - 1];
}

double LGamma1Coefficient::Eval(ElementTransformation &T,
                                const IntegrationPoint &ip) {

  Vector normal(3);
  normal = 0.0;
  compute_normal(T, ip, normal);

  Vector x(3);
  x = 0.0;
  T.SetIntPoint(&ip);
  // Transform integration point from reference coordinates to physical
  // coordinates and store them in the vector
  T.Transform(ip, x);
  int tet_id = -1;
  get_tetId_bdr(pmesh, T.ElementNo, tet_id);
  DenseMatrix sigma = mat[tet_id];
  double mass_coefficient = Beta_value(x, x_c, sigma, normal);
  return mass_coefficient;
}

void RVCoefficient::Eval(Vector &V, ElementTransformation &T,
                         const IntegrationPoint &ip) {
  T.SetIntPoint(&ip);
  Vector x(3);
  x = 0.0;
  // Transform integration point from reference coordinates to physical
  // coordinates and store them in the vector
  T.Transform(ip, x);

  Vector deltaUs(3);
  deltaUs = 0.0;
  gradient_U_i_s(x, x_i, sigma0, deltaUs);
  DenseMatrix temp = sigma0;
  temp -= mat[T.Attribute - 1];
  V.SetSize(3);
  V = 0.0;
  temp.AddMult(deltaUs, V);
}

double RGamma0Coefficient::Eval(ElementTransformation &T,
                                const IntegrationPoint &ip) {
  // compute outer noraml unit vector
  Vector normal(3);
  normal = 0.0;
  compute_normal(T, ip, normal);

  Vector x(3);
  x = 0.0;
  T.SetIntPoint(&ip);
  // Transform integration point from reference coordinates to physical
  // coordinates and store them in the vector
  T.Transform(ip, x);
  double Us = 0.0;
  Us = U_i_s(x, x_i, sigma0);
  double beta = Beta_value(x, x_i, sigma0, normal);
  double mass_coef = beta * Us;
  return mass_coef;
}

double RGamma1Coefficient::Eval(ElementTransformation &T,
                                const IntegrationPoint &ip) {

  //  std::cout<<T.Attribute<<" ";
  // compute outer noraml unit vector
  Vector normal(3);
  normal = 0.0;
  compute_normal(T, ip, normal);

  Vector x(3);
  x = 0.0;
  T.SetIntPoint(&ip);
  // Transform integration point from reference coordinates to physical
  // coordinates and store them in the vector
  T.Transform(ip, x);

  double Us = 0.0;
  Us = U_i_s(x, x_i, sigma0);

  int tet_id = -1;
  get_tetId_bdr(pmesh, T.ElementNo, tet_id);
  DenseMatrix sigma = mat[tet_id];
  double coef1 = Beta_value(x, x_i, sigma, normal) * Us;
  double coef2 = Beta_value(x, x_i, sigma0, normal) * Us;
  double mass_coef = coef2 - coef1;
  return mass_coef;
}
